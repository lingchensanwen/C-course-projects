#if 0
４時間かかちゃった、最初の出力する方法を間違えて、数字の異常が観察できないためからです。
以前は0.1は丁度0.1ではないことだけ知っていたが、いまはさらにわかってきて良かった。
Q1:
1000は整数で、１も整数で、１/1000は整数として処理すれば小数を捨てたら０になる
Q2：
1/a+1 が1.001になる原因：1/1000.0 は近似的に0.001であり、32ビットで表示すれば0.00100000000000000002081668171172である、つまり丸め誤差があり、それとこういう0.001＋１の時、合計には損があり、（32ビットでは）実は1.00099999999999988986587595718447になった、ここで0.001の有効数字で表すと1.001であるから。0.9999999999998899も(1/a+1-1)=0..00099999999999988986587595718447を1000倍にする結果である。しかも16ビットで表すと、0.9999999999998899になる。
Q3：
まずはなぜ誤差が大きくなってしまう理由です。
1/a**5は１より小さいから、1/a**5+1 と１がさらに近いので、桁落ちも発生するから、こうなってしまう。
1.1102230246251565も理解できる、1/a**5は0.00000000000000100000000000000008で、だが前に言った通り、情報落ちと桁落ちで、1/a**5 + 1 −1は0.00000000000000111022302462515654である、あとはa**５倍にして、16ビットで表すと
1.1102230246251565になる。
Q4:1/a**6は１より随分小さいから、情報落ちが発生する（もともとも丸め誤差もある）。
こういうことで、1/a**6＋１＝１になってしまい、１を引くと０になってしまう。
Q5:
A = 1.0
1/pow(a,４)は丸め誤差がないため、桁落ちがなくて、無事１に戻れる。
Q6:
B = 0.0
1/pow(a,6)+1は情報落ちで１になってしまう、１−１＝０
#endif
